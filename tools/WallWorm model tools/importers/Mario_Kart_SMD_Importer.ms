/*--======================================--*\
SOURCE - SMD Importer
By: Mario_Kart64n
Date: January 13, 2013

(Jan13/2013)
Core of importer written :D

This script written by Corey Nguyen.
http://www.facebook.com/corey.van.nguyen
http://www.youtube.com/user/mariokart64n


and by Shawn Olson for use in Wall Worm.
http://www.shawnolson.net

Included in Wall Worm with permission.
http://dev.wallworm.com


QC Parsing and Importing by Shawn Olson. Added on 2-3-2013 .

Animation Importing added on 4-23-2012

Now requires the FGD parser functions to be included.

*/--======================================--\*

fileIn "$scripts\\WallWorm.com\\custom_attributes\\bodygroups.ms"

struct tmplod (
	val = 1,
	replacemodels = #(),
	qciincludes = #()
)

function wallworm_import_smd fsource materialp:undefined removeUnweightedBonesFromSkin:false rotateModel:false rotationAmount:90 zeroRotations:false xf:false uniqueNames:false collapseMeshes:false staticprop:true isSequence:false timeOffset:0 addToTimeline:false skipAnimation:false nodePrefix:"" deepSearchMaterials:true= (
	set coordsys world
	max create mode
	local buildMsh = (NOT isSequence)
	local buildSkn = (NOT isSequence)
	local buildSkl = true
	local msh = undefined
	local meshes = #()
	--local rootRotationAnglesStore = undefined
	local rootOffsetPositionStore = undefined
	
	global wallworm_skinops_getBoneNameByListID 

	
	if (fsource!=undefined) AND ((doesFileExist fsource)==true) then (
		LOCAL f=MemStreamMgr.openFile fsource
		

		fn parseblock fstream = (
			string_array = #()
			tag = fstream.readLine()
			while tag != "end" AND fstream.eos() != true do (
				
				tag = trimleft tag

				--lines to ignore until support for these features are added (to speed gneeration up)		
				if ( tag != "" AND  (( (substring tag 1 2) != "//") AND matchpattern tag pattern:"*File generated by the Wall Worm*" == false AND  matchpattern tag pattern:"*Created by Crowbar*" == false) )  then (

					append string_array tag
				)
				tag = fstream.readLine()
			)
			return string_array
		)

		fn relativetoworld obj obj2 idx = ( -- realtive to world positions
			pos = obj.matrix[idx]
			par = obj2.parent[idx]
			if par != undefined AND par!=0 then (
				while par != 0 do (
				pos*= obj.matrix[par]
				par = obj2.parent[par]
				)
			)else(
			-- pos*=(rotateX pos 90)
			)
			return pos
		)

		while (toLower (trimLeft(trimRight(f.readLine())))) != "version 1" do (
			--print (f.readLine())
		)
		
		
		struct smd_format (header,nodes,skeleton,bones,triangles)
		struct smd_header (version)
		struct smd_nodes (index,name,parent)
		struct smd_skeleton (frame,bone)
		struct smd_bone (index,matrix)
		struct smd_triangles (material,geometry)
		struct smd_vertex (parent,position,normal,texture,count,boneid,weight,faces)
		local smdArray
		smdArray = (smd_format header:#() nodes:#() skeleton:#() bones:#() triangles:#())
		smdArray.header = (smd_header version:("version 1"))
		smdArray.nodes = (smd_nodes index:#() name:#() parent:#())
		smdArray.skeleton = (smd_skeleton frame:#() bone:#())
		smdArray.triangles = (smd_triangles material:#() geometry:#())
		local highestBoneCount = 1
		face_lookup = #()
		local weightedBones = #{}
		/*
		 Will add this block back to the code when updated to ignore opening comments.	
		*/
		--if smdArray.header.version == "version 1" then (
			

			
		while f.eos() != true do (

			
			local smd_element = f.readLine()
			

			
			smd_element = trimleft smd_element
			smd_element = trimRight smd_element
			smd_element = substituteString smd_element "\t" " "
			smd_element = substituteString smd_element "  " " "
			
			--lines to ignore until support for these features are added (to speed gneeration up)		
			if (smd_element == undefined OR smd_element == "" OR (( (substring smd_element 1 2) == "//")  OR matchpattern smd_element pattern:"*File generated by the Wall Worm*") ) then (
				--oops... probably a comment
				--print ("Skipping this line: "+ smd_element)
			) else (
			
			

			strArray = parseblock f
			case smd_element of (
				"nodes":(
					for i = 1 to strArray.count do (
				/*		local theString = (strArray[i] as stringstream) as string
						substituteString theString "\t" " "
						while (matchpattern theString pattern:"*  *") do (
							theString = substituteString theString "  " " "
						)
						values = filterString theString " "
						
					if values.count == 3 then (
						
						smdArray.nodes.index[i] = values[1]
						smdArray.nodes.name[i] = substituteString values[1] "\"" ""
						smdArray.nodes.parent[i] = values[3]
					)*/
						

					smdArray.nodes.index[i] = (readDelimitedString (strArray[i] as stringstream) "\"")
					smdArray.nodes.name[i] = (strArray[i] as stringstream);skipToString (smdArray.nodes.name[i] as stringstream) "\""
					smdArray.nodes.name[i] = readDelimitedString (smdArray.nodes.name[i] as stringstream) "\""
					smdArray.nodes.parent[i] = (strArray[i] as stringstream)
					skipToString (smdArray.nodes.parent[i] as stringstream) "\""
					skipToString (smdArray.nodes.parent[i] as stringstream) "\""
					smdArray.nodes.parent[i] = (execute (readDelimitedString (smdArray.nodes.parent[i] as stringstream) ""))+1						/**/
					) 
				)
				"skeleton":(
					cnt = 1
					while cnt<=strArray.count do (
						delimited = filterString strArray[cnt] " ";cnt+=1
						frame_index = (delimited[2] as integer)+1
						smdArray.skeleton.frame[frame_index]=frame_index
						smdArray.skeleton.frame[frame_index]=(smd_bone index:#() matrix:#() )
						do (
							delimited = filterString strArray[cnt] " "
							if delimited[1]!="time" then (
								bone_index = (delimited[1] as integer)+1
								
								rootRotationAngles= eulerAngles \
								(radToDeg (execute delimited[5])) \
								(radToDeg (execute delimited[6])) \
								(radToDeg (execute delimited[7]))
									
								if rootRotationAnglesStore == undefined then (
									
									if zeroRotations == true then (
										rootRotationAngles = eulerAngles 0 0 0
									)
									
									rootRotationAnglesStore = rootRotationAngles
								)
								
								bone_matrix = rootRotationAngles as matrix3
								bone_matrix.row4 = [(execute delimited[2]),(execute delimited[3]),(execute delimited[4])]
								smdArray.skeleton.frame[frame_index].index[bone_index]=bone_index
								smdArray.skeleton.frame[frame_index].matrix[bone_index]=bone_matrix
								--smdArray.skeleton.frame[frame_index].rangle[bone_index]=rootRotationAngles	
									
								cnt+=1
							)else(
								frame_index = delimited[2] as integer
							)
						) while delimited[1]!="time" AND cnt<=strArray.count
					)
				)
				"triangles":(
					cnt = 0
					mat_id = 0

					for i = 1 to (strArray.count/4) do (
						cnt = ((i-1)*4)+1
						tex_name = strArray[cnt];cnt+=1

						find = findItem smdArray.triangles.material tex_name
						if find!=0 then (mat_id=find) else(
						mat_id=smdArray.triangles.material.count+1
						face_lookup[mat_id]=#()
						smdArray.triangles.geometry[mat_id]=(smd_vertex parent:#() position:#() normal:#() texture:#() count:#() boneid:#() weight:#() faces:#())
						smdArray.triangles.material[mat_id]=tex_name
						)

						for x = 1 to 3 do (
							delimited = filterString strArray[cnt] " ";cnt+=1
							boneid = delimited[1] as integer
							local realBoneID = boneid + 1

							
							position = [(execute delimited[2]),(execute delimited[3]),(execute delimited[4])]
							normal = [(execute delimited[5]),(execute delimited[6]),(execute delimited[7])]
							texture = [(execute delimited[8]),(execute delimited[9]),0]
							local skipBoneCount = false
							if delimited[10] != undefined  then (
								
								bone_id_count = delimited[10] as integer
							) else (
								skipBoneCount = true
								bone_id_count = 1
								weightedBones[realBoneID] = true
								
							)
							id_index = 11
							bi = #();bw = #()
							
							local rootBoneIndex = undefined
							
							if skipBoneCount == false then (
								
								
								local wts = 0.0
								for y = 1 to bone_id_count do (
								local thisBoneID = (delimited[id_index] as integer)+1

									
									
								bi[y]=(thisBoneID);id_index+=1
								weightedBones[bi[y]] = true
								bw[y]=(thisBoneID);id_index+=1
								if  thisBoneID == realBoneID then (
									rootBoneIndex = y
								)
									wts += bw[y]
								)
								

								if wts < 1.0 then (
									weightedBones[realBoneID] = true
									
									local diff = 1.0 - wts	
									
									--format "\n##\nDif %\n" diff
									if rootBoneIndex != undefined then (
										
										bw[y] += diff 
										
										--format "\n##\nADDING Added to make %\n" bw[y]
										
									) else (
										bone_id_count += 1
										
										bi[bone_id_count]=diff
										bw[bone_id_count]=diff
										--format "\n##\nSetting WEIGHT to bone: % \n" bone_id_count
									)
								)
								
								
								if bone_id_count > highestBoneCount then (
									highestBoneCount = bone_id_count
								)
								
								
							) else (

								bi[1]=(1)
								bw[1]=(1)


							)
							str = (position+normal+texture)*bone_id_count
							find = findItem face_lookup[mat_id] str
							if find == 0 then (
								find = smdArray.triangles.geometry[mat_id].position.count
								append face_lookup[mat_id] str
								append smdArray.triangles.geometry[mat_id].faces (find+1)
								append smdArray.triangles.geometry[mat_id].parent boneid
								append smdArray.triangles.geometry[mat_id].position position
								append smdArray.triangles.geometry[mat_id].normal normal
								append smdArray.triangles.geometry[mat_id].texture texture
								append smdArray.triangles.geometry[mat_id].count bone_id_count
								append smdArray.triangles.geometry[mat_id].boneid bi
								append smdArray.triangles.geometry[mat_id].weight bw
							)else(
								append smdArray.triangles.geometry[mat_id].faces find
							)
						)
					)
				 --print smdArray.triangles.material
				)
			)
			)
		)
		boneArray=#()
		bone_count = smdArray.skeleton.frame[1].matrix.count
		
		global wallworm_smd_import_time
		

		
		
		if wallworm_smd_import_time != undefined then (
			wallworm_smd_import_time += smdArray.skeleton.frame.count
		) else (

		)
		
		for i = 1 to bone_count do (
			
			
		for framenum = 1 to smdArray.skeleton.frame.count do (			
			
			
			bone_transform = relativetoworld smdArray.skeleton.frame[framenum] smdArray.nodes i
			
			if bone_transform == undefined then (
					bone_transform = matrix3 1
			)
			
			bone_ext = bone_transform.row4+[0,0,4]
			find = findItem smdArray.nodes.parent i
			if find!=0 do (
				bone_ext = relativetoworld smdArray.skeleton.frame[framenum] smdArray.nodes find
				
				bone_ext = bone_ext.row4
			)

			
			/*
			
			!TODO ... check for existing bones in scene with this name and re-use it.
			
			Maybe make this optional.
			
			*/
			local bb
			if smdArray.nodes.name[i] != undefined then (
				smdArray.nodes.name[i] = smdArray.nodes.name[i] as string
				bb = getNodeByName (smdArray.nodes.name[i])
			)

			
			if bb == undefined OR isDeleted bb then (

				bb=(BoneSys.createBone bone_transform.row4 bone_ext [0,0,1])	

				bb.showLinks = true
				bb.showLinksOnly = true
				bone_size = 1
				bb.width = bone_size
				bb.height = bone_size
				bb.transform = bone_transform
				bb.length = 0.1
				bb.boneEnable = true	


				
			
				if smdArray.nodes.name[i] != undefined then (
					if uniqueNames == true then (
						
						smdArray.nodes.name[i] = (uniqueName (smdArray.nodes.name[i] as string))
							
					) else (
							
							smdArray.nodes.name[i] = smdArray.nodes.name[i] as string
					)
					bb.name = smdArray.nodes.name[i]
				)
				
			)	else (
				--format "% to % at % (offset: %)\n"  bb.name   bone_transform (framenum+timeOffset) timeOffset
				if NOT skipAnimation then (
					with animate on (
						at time (framenum+timeOffset)	bb.transform = bone_transform	
						smdArray.nodes.name[i] = smdArray.nodes.name[i] as string
					)
				)
			)

			if bb != undefined AND isDeleted bb == false then (
				append boneArray bb
			)
			

			
		)
		
	)
	

		if isSequence == false then ( 
	
				for i = 1 to bone_count do (
					par = smdArray.nodes.parent[i]
					if par != undefined AND par!=0 AND ( boneArray[i].parent == undefined AND boneArray[i].parent != boneArray[par] AND NOT  refs.dependencyLoopTest boneArray[i] boneArray[par]) then (
						boneArray[i].parent = boneArray[par]
						-- boneArray[i].realignBoneToChild() -- poo dont work, grr
					) else (
						if zeroRotations == true AND (par == undefined OR par==0) then (
											
							boneArray[i].transform = matrix3 1
							)
						
						)
				)
		)

	
	

	
	
		if staticprop==true then (
			delete boneArray
			boneArray = #()
		) 
		
		global wallworm_debug
		if wallworm_debug != undefined AND wallworm_debug == true then (
			global wallworm_smdArrays
			if wallworm_smdArrays == undefined then (
				wallworm_smdArrays = #()
			)
			
			append wallworm_smdArrays smdArray
		)
		local fsourcepath = undefined
		if deepSearchMaterials then (
			local fsourcepath = #((getFileNamePath fsource))
		)
		if buildMsh == true do (
			
			
			
			num_elements = smdArray.triangles.material.count
			local mat = multimaterial numsubs:num_elements
			mat.numsubs = num_elements
			--meditMaterials[1] = mat
			for i = 1 to num_elements do (
				
				
				
				basename = getFilenameFile smdArray.triangles.material[i]

				--local theVMT = wallworm_getVMTFromPaths (smdArray.triangles.material[i]) extraPath:materialp
				
				
				
				local theVMT = wallworm_VMFIMPORT_getMaterial (basename)  color:undefined openLib:false matType:"model" extraPath:materialp extraRootPaths:fsourcepath
				
				if  theVMT != undefined then (
						mat.materialList[i] = theVMT
						--mat.materialList[i] = wallworm_generateMaterialFromVMT theVMT matType:"model" extraPath:materialp 
						submat = mat.materialList[i]
				) else (
					
					submat = mat.materialList[i]
					submat.diffuseMap = Bitmaptexture fileName:smdArray.triangles.material[i]
					submat.name = basename
					
				)


				faceArray = #()
				nfaceArray = #()
				vertArray = smdArray.triangles.geometry[i].position
				normArray = smdArray.triangles.geometry[i].normal
				uvwArray = smdArray.triangles.geometry[i].texture
				vert_count  = smdArray.triangles.geometry[i].position.count
				face_count = smdArray.triangles.geometry[i].faces.count/3

				cnt = 0
				for x = 1 to face_count do (
					fa = smdArray.triangles.geometry[i].faces[(cnt+1)]
					fb = smdArray.triangles.geometry[i].faces[(cnt+2)]
					fc = smdArray.triangles.geometry[i].faces[(cnt+3)]
					faceArray[x]=[fa,fb,fc];
					
					/*					
					nfa = smdArray.triangles.geometry[i].normal[(cnt+1)]
					nfb = smdArray.triangles.geometry[i].normal[(cnt+2)]
					nfc = smdArray.triangles.geometry[i].normal[(cnt+3)]
					nfaceArray[x]=smdArray.triangles.geometry[i].normal;
*/
					
					
					
					cnt += 3
				)


				msh = mesh vertices:vertArray faces:faceArray-- materialIDs:matidArray

				msh.numTVerts = vert_count
				buildTVFaces msh
				msh.displayByLayer = false
				msh.backfacecull = on
				msh.wirecolor = random (color 0 0 0) (color 255 255 255)
				msh.material = submat
				msh.name = uniqueName (getFileNameFile fsource)
				
				if smdArray.skeleton.frame[1].matrix[i] != undefined then (
					rootRotationAnglesStore=smdArray.skeleton.frame[1].matrix[i].rotationPart as eulerAngles
				) else (
						rootRotationAnglesStore = eulerAngles 0 0 0
				)
				setUserProp msh "ImportedSMDRotations" (rootRotationAnglesStore as string)
				
				for j = 1 to uvwArray.count do setTVert msh j uvwArray[j]
				for j = 1 to faceArray.count do setTVFace msh j faceArray[j]
				for j = 1 to normArray.count do setNormal msh j normArray[j]


				--EN.ConvertVertexSelection vertexSelection normalSelection
					
				/*
				local newT = relativetoworld smdArray.skeleton.frame[1] smdArray.nodes i
			
				if newT != undefined then (
					msh.transform = newT
				)
				
				*/

				
				if zeroRotations == true then (
					
					msh.pos = [0,0,0]
					
					
				)
					
				
					if rotateModel == true then (
						--msh.transform = msh.transform * rotateZMatrix rotationAmount
						--msh.transform = rotateZMatrix rotationAmount * msh.transform
					)
					
					
/*					*/
					
			
					
					
				--smdArray.skeleton.frame[1].matrix.
				

				if  zeroRotations == true  then (
					
					
					
				-- msh.transform =	(rotateYPRMatrix rootRotationAnglesStore.z rootRotationAnglesStore.y rootRotationAnglesStore.x) * msh.transform


					--smdArray.nodes i
				
					
					if rootRotationAnglesStore.z != 0 then (
						--msh.transform = rotateZMatrix (rootRotationAnglesStore.z * -1) * msh.transform
						in coordsys msh rotate msh (angleaxis (rootRotationAnglesStore.z * -1)  [0,0,1]) -- z
						
					)
					

					
					if rootRotationAnglesStore.y != 0 then (
						in coordsys msh rotate msh (angleaxis (rootRotationAnglesStore.y )  [0,1,0]) -- y
					)
					
					if rootRotationAnglesStore.x != 0 then (
						
						--msh.transform = rotateXMatrix rootRotationAnglesStore.z * msh.transform
						in coordsys msh rotate msh (angleaxis (rootRotationAnglesStore.x )  [1,0,0]) -- x
					)
					
					

				)
					

					if rotateModel == true then (
						--msh.transform = msh.transform * rotateZMatrix rotationAmount
						msh.transform = rotateZMatrix rotationAmount * msh.transform
					)
				
					update msh
					
				
					
					
					
					if xf == true then (
						resetXForm msh
					)	
					
					
					
					
				convertToPoly msh	
					
/*
				local EN = Edit_Normals()
				addModifier msh EN
					
				for j = 1 to nfaceArray.count do EN.SetNormal  j nfaceArray[j]
					
										*/




					
					--

				

				if buildSkn == true AND boneArray.count > 0 do (

					skinMod = skin ()
					addModifier msh skinMod
					max modify mode
					
					
					skinMod.bone_Limit = 1
					skinMod.initialStaticEnvelope = true
										
					/*skinMod.initialInnerEnvelopePercent =0.0 
					skinMod.initialOuterEnvelopePercent =0.0 */
					skinMod.initialEnvelopeInner = 0.01 
					skinMod.initialEnvelopeOuter = 0.01 

					skinMod.rigid_vertices = true /*	*/

					
					select msh
					for x = 1 to bone_count do (
						if x!=bone_count
						then (skinOps.addbone skinMod boneArray[x] 0)
						else (skinOps.addbone skinMod boneArray[x] 1)
					)
					
					skinMod.bone_Limit = highestBoneCount
					skinMod.rigid_vertices = false
					boneIDMap = #()
					for x = 1 to bone_count do (
						boneNameIdx = findItem smdArray.nodes.name (wallworm_skinops_getBoneNameByListID skinMod x 0)
						--boneNameIdx = findItem smdArray.nodes.name (skinOps.GetBoneName skinMod x 0)
						if boneNameIdx==0 do (boneNameIdx=1);boneIDMap[x]=boneNameIdx
					)
					modPanel.setCurrentObject skinMod
					for x = 1 to vert_count do (
						
						
						bi = smdArray.triangles.geometry[i].boneid[x] 
						

							bw = smdArray.triangles.geometry[i].weight[x]
							for j = smdArray.triangles.geometry[i].count[x] to 1 do (
								tmp =  findItem boneIDMap bi[j]
								if tmp != 0 then (
									bi[j]=tmp
								) else (
									bi[j]=1
								)
								
								
							)
							skinOps.ReplaceVertexWeights skinMod x bi bw


							skinMod.clearZeroLimit = 0.00
							skinops.removeZeroWeights skinMod
							
						--print ""
					)
					
					
					
					if removeUnweightedBonesFromSkin then (
							/*Do not insert any bones that are not in the list*/

					

							for removeID = bone_count to 1 by -1 do (
								
								if  weightedBones[removeID] == false then (
									--format "Remove Bone %\n" removeID
									skinOps.removeBone skinMod removeID
								
									max create mode
									max modify mode
									modPanel.setCurrentObject skinMod	/**/
									/*skinops.invalidate skinMod 1
									skinOps.resetAllBones skinMod
									forcecompleteredraw()*/
								)
								
							)
							
							
						
					)
					
					
					

				)

				
				append meshes msh
			)


		)

		
		
		
		
		if addToTimeline == true then (
			sliderTime +=  smdArray.skeleton.frame.count
		)
		
		--)else(messagebox "Error\nSMD Not Compatible with this Script")
		Print (fsource+" Imported")
		MemStreamMgr.close f


	) else (

	)		

	global wallworm_debug
	if wallworm_debug = true then (
		
		global ww_smdarray
		if ww_smdarray == undefined then (
			ww_smdarray = #()
		)
		append ww_smdarray (#(smdArray,meshes))
		
	)
	
	
	if meshes.count > 1 AND collapseMeshes == true then (
			att = polyop.attach
			m = meshes[1]
			for i = 2 to meshes.count do (
				
				att m meshes[i]
			)
		meshes = #(m)
	)
	
	return meshes
)





function wallworm_getSMDsFromPaths smdfile modelname qcfile extraPaths:undefined = (
	max create mode

	if smdfile != undefined then (
	/*
			This function returns a filename (with path) of a SMD represented by the modelname or undefined if not found.
	*/	
		if  doesFileExist smdfile then ( 
			return smdfile
		)
		
		global wwmt_gameInfoDir
		global wwmt_export
		patharray = #()
		
		
		
		if extraPath != undefined then (
			
			if classOf extraPaths == Array then (
				
				join patharray extraPaths
			) else (
				appendIfUnique patharray (extraPath)
			)
			
		)
		appendIfUnique patharray (wwmt_gameInfoDir + "\\models\\")
		appendIfUnique patharray (wwmt_export)
		
		
		if modelname != undefined then (
			appendIfUnique patharray (getFileNamePath modelname)
			appendIfUnique patharray (wwmt_export+"\\"+ getFileNamePath modelname)
		)
		
		appendIfUnique patharray (getFileNamePath smdfile)
		appendIfUnique patharray (wwmt_export+"\\"+ getFileNamePath smdfile)
		
		
		appendIfUnique patharray (getFileNamePath qcfile)
		appendIfUnique patharray (wwmt_export+"\\"+ getFileNamePath qcfile)
		
		global wallworm_debug
		if wallworm_debug == true then (
			print patharray
		)
		
		local smdfname = getFileNameFile smdfile
		
		if getFileNameType smdfname != "" then (
			for p in patharray do (
				smd = (p+"\\"+(smdfname))
				if doesFileExist smd then (
					return smd
				)
			)
		) else (
			
			for p in patharray do (
				
				smd = (p+"\\"+(smdfname)+".smd")

				if doesFileExist smd then (
					
					return smd
				)
				
				smd = (p+"\\"+(smdfname)+".dmx.smd")
				if doesFileExist smd then (
					
					return smd
				)
				
			)			
			
		)
		
		
		

		
	)
	
	return undefined

)

struct qclod (
	val = 1,
	replacemodels = #(),
	qciincludes = #(),
	replacematerials = #()
)



struct qcbg (
	name,
	bgs=#()
)

struct wallworm_qc_struct (
		wwmt = undefined,  
		model = undefined,
		phys = undefined,
		staticprop = undefined,
		modelname = undefined,
		shortModelName = undefined,
		materialp="",
		surfaceprop = undefined,
		concave = undefined,
		opaque = undefined,
		mostlyopaque = undefined,
		mass  = undefined,
		inertia  = undefined,
		damping  = undefined,
		rotdamping  = undefined,
		jointconstrain = false,
		shadowlod = false,
		texgroupname = "",
		texturegroup = #(),
		bodygroups = #(),
		sc = 1.0,
		lods = #(),
		lodvals = #(),
		seqvals = #(),
		sequences = #(),
		paths=#(),
		importedFiles = #(),
		includesToAdd = #(),
		unclassified = #()
	
)


function wallworm_update_qcobject &qc fsource skipLODS:false= (
	
		append qc.paths (getFileNamePath fsource)
		append qc.importedFiles (fileNameFromPath fsource)
		--local theQC = openFile fsource
	
		local theQC = MemStreamMgr.openFile fsource
	
		if theQC == undefined then (
			return undefined
		)
		
		if theQC.pos() != 0 then (
			theQC.seek 0 #seek_set
		)
		local theline
		while theQC.eos() == false AND theQC.peekToken() != undefined do (
			

			
			theQC.skipSpace()
			startPos = theQC.pos()
			theline = (theQC.readLine())
			endPos = theQC.pos()

			local val, param
			
			theLine = trimleft theLine
			theLine = trimRight theLine
			--theLine = substituteString theLine "\tab" " "
			theLine = substituteString theLine "\t" " "
			theLine = substituteString theLine "  " " "
			
			--lines to ignore until support for these features are added (to speed gneeration up)		
			if (theLine == "" OR theLine == undefined OR ( (substring theLine 1 2) == "//") ) do continue
				
			
			lineArray = filterString theLine " "
				
			if lineArray.count >= 1 then (
				param = lineArray[1]
				
				) else (
				
				param = theLine
				
				)
	
			if lineArray.count > 1 then (
				val = lineArray[2]
				
				) else (
				
				val = undefined
				
				)
			
				param  = substituteString param "\"" ""
				

				if val != undefined then (
					val  = substituteString val "\"" ""

				)
				
				
				--format "############\nParameter:\t%\nValue:\t%\n" param val
				
				
				if (matchPattern param pattern:"*$include*" ) == true AND val != undefined AND findItem qc.importedFiles (fileNameFromPath val) == 0 then (
					local hasFoundFile = false
					for pth in qc.paths while hasFoundFile == false do (
						local lookfor = pth+val
						if doesFileExist (lookfor) then (
							--print (lookfor + " found... parsing")
							wallworm_update_qcobject &qc lookfor
							hasFoundFile = true
						) else (
							--print (lookfor + " NOT found...")
						)
					)
					
					if hasFoundFile == false then (
						appendIfUnique qc.includesToAdd val
						
					) else (
						
						local ind = findItem qc.includesToAdd val
						if ind != 0 then (
							deleteItem  qc.includesToAdd ind
						)
					)
					
					/*
					print (val)
					print qc.paths*/
					continue
				)
				
				
				
				
				
				
				if (matchPattern param pattern:"*$modelname*" ) == true AND val != undefined then (
					qc.shortModelName = getFileNameFile val
					qc.modelname = val
					continue
				)
				
				if (matchPattern param pattern:"*$body*" == true OR matchPattern param pattern:"*$model*" == true) AND  lineArray[3] != undefined then (

					if matchPattern param pattern:"*$bodygroup*" == true AND qc.model == undefined then (
						qc.model = substituteString (lineArray[2]) "\"" ""
						print "getting bg"
					) else (
						qc.model = substituteString (lineArray[3]) "\"" ""
						continue
					)
					
					
					
					
					
				)
				
				if (matchPattern param pattern:"*$collisionjoints*" == true) AND val != undefined then (
					
					
					qc.jointconstrain = true
					qc.concave = true

				)

				if (matchPattern param pattern:"*$collisionmodel*" == true OR matchPattern param pattern:"*$collisionjoints*" == true) AND val != undefined then (
					

					qc.phys = substituteString (val) "\"" ""
					continue
				)
				
				

				/*
				if matchPattern param pattern:"*$lod*" == true AND val != undefined then (
					if NOT skipLODS then (
						append qc.lodvals val
						
					)
					continue
				) else (

					
					if matchPattern param pattern:"*$shadowlod*" == true  then (
						if NOT skipLODS then (
							qc.shadowlod = true
						)
						continue
					)
					
				)
*/
				
				
				if matchPattern param pattern:"*$sequence*" == true  then (
					append qc.seqvals lineArray
					continue
				)
				
				
				if matchPattern param pattern:"*$staticprop*" == true  then (
					qc.staticprop = true
					continue
				)
				if matchPattern param pattern:"*$surfaceprop*" == true AND val != undefined then (
					qc.surfaceprop = val
					continue
				)
				if matchPattern param pattern:"*$concave*" == true then (
					qc.concave = true
					continue
				)
				
				
				if matchPattern param pattern:"*$mass*" == true AND val != undefined then (
					qc.mass = val
					continue
				)
				
				if matchPattern param pattern:"*$scale*" == true AND val != undefined then (
					qc.sc = val as float
					
				
					continue
				)
				

				
				
				if matchPattern param pattern:"*$inertia*" == true AND val != undefined then (
					qc.inertia = val
					continue
				)
				if matchPattern param pattern:"*$damping*" == true  AND val != undefined then (
					qc.damping = val
					continue
				)
				if matchPattern param pattern:"*$rotdamping*" == true AND val != undefined then (
					qc.rotdamping = val
					continue
				)

				
				
				
				
				if matchPattern param pattern:"*$opaque*" == true then (
					qc.opaque = true
					continue
				)
				if matchPattern param pattern:"*$mostlyopaque*" == true then (
					qc.mostlyopaque = true
					continue
				)
				


				
				if matchPattern param pattern:"*$texturegroup*" == true AND val != undefined AND val != "" then (
					qc.texgroupname = val
					qc.texturegroup = #()
					if matchPattern param pattern:"*{*"  then (
						
						theQC.seek startPos
						

					)
					
					local str = theQC.readBlock "{" "}"
					if str != undefined AND str != "" then (
						
						str = substituteString (substituteString  (substituteString str "{" "") "}" "") "\"" "" 
						
						local texGstr = MemStreamMgr.openString str
						local choicesarray = #()
						local splitStr
						local theFlagLine
						 while texGstr.eos() == false AND texGstr.peekToken() != undefined do (
							 
							texGstr.skipSpace()
							texLine = texGstr.readLine()
							 
							texLine =  trimRight(trimLeft (texLine ))
							newTextures = filterString texLine " "
							if newTextures.count > 0 then (
								append qc.texturegroup newTextures
							)
								
							 
						 )
						 
						 MemStreamMgr.close texGstr
						
					)
					
					
					
					continue

				)
				
				
				
				if matchPattern param pattern:"*$lod*" == true AND val != undefined AND val != "" then (
					

					ld = qclod()
					ld.val = trimLeft(trimRight(substituteString (substituteString val "{" "") "\"" ""))
						
						

					
					if matchPattern param pattern:"*{*"  then (
						
						theQC.seek startPos
					)
					
					local str = theQC.readBlock "{" "}"
					if str != undefined AND str != "" then (
						
						str = substituteString (substituteString  (substituteString str "{" "") "}" "") "\"" "" 
						local texGstr = MemStreamMgr.openString str
						local choicesarray = #()
						local splitStr
						local theFlagLine
						 while texGstr.eos() == false AND texGstr.peekToken() != undefined do (
							 
							texGstr.skipSpace()
							texLine = texGstr.readLine()
							 
							 
							texLine =  trimRight(trimLeft (texLine ))
							newld = filterString texLine " "	
								
							if matchPattern texLine pattern:"*replacemodel*" == true AND newld[3] != undefined then (
								append ld.replacemodels (substituteString (newld[3]) "\"" "")
							)
								
								
							
							if matchPattern texLine pattern:"*replacematerial*" == true AND newld[3] != undefined then (
								append ld.replacematerials (substituteString (newld[3]) "\"" "")
							)

								
							 
						 )
						 
						 MemStreamMgr.close texGstr
						
					)
					
					if ld.replacemodels.count > 0 then (
						
						append qc.lods ld
					)
					
					continue

				)

				
				

				
				if matchPattern param pattern:"*$bodygroup*" == true AND val != undefined AND val != "" then (
					bg = qcbg()
					bg.name = val
					
					if matchPattern param pattern:"*{*"  then (
						
						theQC.seek startPos
					)
					
					local str = theQC.readBlock "{" "}"
					if str != undefined AND str != "" then (
						
						str = substituteString (substituteString  (substituteString str "{" "") "}" "") "\"" "" 
						local texGstr = MemStreamMgr.openString str
						local choicesarray = #()
						local splitStr
						local theFlagLine
						 while texGstr.eos() == false AND texGstr.peekToken() != undefined do (
							 
							texGstr.skipSpace()
							texLine = texGstr.readLine()
							 
							texLine =  trimRight(trimLeft (texLine ))
							newbg = filterString texLine " "
							if newbg.count > 1 then (
								append bg.bgs newbg[2]
							)
								
							 
						 )
						 
						 MemStreamMgr.close texGstr
						
					)
					
					if bg.bgs.count > 0 then (
						
							append qc.bodygroups bg
					)
					
					continue

				)

			
				if matchPattern param pattern:"*$cdmaterials*" == true AND val != undefined AND val != "" then (
					qc.materialp = val
					continue

				)
				
				if matchPattern param pattern:"*$shadowlod*" == true  then (
					if NOT skipLODS then (
						qc.shadowlod = true
					)
					continue
				)

				
				
				
				--"$jointmerge","$jointmassbias","$jointconstrain",
				unclassed = #("$ikchain","$alwayscollapse","$root","$poseparameter","$weightlist","$definebone","$hboxset","$hbox","$attachment","$eyeposition","$bbox","$proceduralbones")
				
				
				for u in unclassed do (
					
					if matchPattern param pattern:("*"+u+"*") == true AND val != undefined AND val != "" then (
						appendifUnique qc.unclassified  theLine
						continue

					)
				
				)
				
				
				
			

				
			)
			memStreamMgr.close theQC
			
)



function wallworm_make_wwmt_from_smd_in_qc qc smd  rotateModel:false rotationAmount:90  zeroRotations:false staticprop:false  xf:false  uniqueNames:false collapseMeshes:false buildMesh:true scaleMesh:false extraSequences:undefined skipLODS:false deepSearchMaterials:false = (
	local wwmt
	meshes = wallworm_import_smd smd  materialp:qc.materialp   staticprop:qc.staticprop staticprop:qc.staticprop
	
	if meshes.count == 0 then (
			return undefined
	)
	
	msh = meshes[1]
	
	if isValidNode msh == false then (
		return undefined
		)
	local wwmt = ww_LOD_wrapper()
	wwmt.setTargetModel msh wwmt
	
	wwmt.target.getWWMT()
		
	if newMultiMat != undefined then (
		wwmt.target.mat = newMultiMat
	)	
		
	/*							*/
	if wwmt.targets.count < 1 OR wwmt.targets[1] == undefined then (
		return undefined
	)	
	
	if rotateModel == true then (
		
		if rotationAmount != undefined then (
				setUserProp wwmt.target "imported_rotation_offset" (rotationAmount as string)
		)
		wwmt.setRotateRefsystem true						
	) else (
		
		wwmt.setRotateRefsystem false		
	)

	if zeroRotations == true then (	)
	wwmt.setinternalOrigin true
	wwmt.setLocalOrigin true		

	wwmt.setNormalMethod 2
	
	wwmt.setModelName(qc.shortModelName)
	wwmt.target.modelName = qc.shortModelName
	
	
	if qc.materialp != undefined AND qc.materialp != "" then (
		wwmt.setMaterialPath(qc.materialp)
	)

	wwmt.setModelPath(getFileNamePath qc.modelname)
	
	if qc.staticprop != undefined then (wwmt.setStaticprop(true)) else (
		wwmt.setStaticprop(false)
	)
	if qc.surfaceprop != undefined then (wwmt.setSurfaceProperty(qc.surfaceprop))
	if qc.concave != undefined then (wwmt.setConcave(true))
	if qc.opaque != undefined then (wwmt.setOpaque( true))
	if qc.mostlyopaque != undefined then (wwmt.setMostlyOpaque(true))
		
	if qc.mass != undefined then (wwmt.setMass(qc.mass))
	if qc.inertia != undefined then (wwmt.setInertia(qc.inertia))
	if qc.damping != undefined then (wwmt.setdamping(qc.damping))
	if qc.rotdamping != undefined then (wwmt.setRotDamping(qc.rotdamping))

	if qc.jointconstrain == true then (wwmt.setJointConstraints(true))	
	if qc.shadowlod == true then (wwmt.setShadowlod(true))	
		
		
	if meshes.count > 1 then (
			for n = 2 to meshes.count do (
					wwmt.addObjToObjects meshes[n]
			)
	)	
	
	local scaleSMDs = false
	if qc.sc != undefined AND qc.sc != 0.0 AND qc.sc != 1.0 then (
		
		if scaleMesh == true then (
			scaleSMDs = true
			
			
		) else (
			
			wwmt.setScale(sc)
		)
		
		
		
	)
	
	
	
	if scaleSMDs == true then (
		
		toScale = for obj in meshes WHERE obj.parent == undefined collect obj
		
		toScale.scale *= qc.sc
		if xf == true then (
		
			resetXForm toScale
			convertToPoly toScale
			
		)
	)
	

	wwmt
)

function wallworm_parse_qc fsource removeUnweightedBonesFromSkin:false rotateModel:false rotationAmount:90  zeroRotations:false staticprop:false  xf:false  uniqueNames:false collapseMeshes:false buildMesh:true scaleMesh:false extraSequences:undefined skipLODS:false deepSearchMaterials:false= (
max create mode
local dfltInTangentType=#step,dfltOutTangentType=#step, OLDdfltInTangentType,OLDdfltOutTangentType

maxOps.getDefaultTangentType OLDdfltInTangentType OLDdfltOutTangentType
	
	
maxOps.setDefaultTangentType dfltInTangentType dfltOutTangentType writeInCfgFile:false

	


	
		global wallworm_smd_import_time = sliderTime
	
	
		global qc = wallworm_qc_struct()
	
		
		wallworm_update_qcobject &qc fsource  skipLODS:skipLODS
	
	
		local newMultiMat
		if qc.texturegroup.count > 0 then (
			
			newMultiMat = MultiMaterial name:(qc.texgroupname) numsubs:qc.texturegroup.count

			extaPath = getFileNamePath fsource
			skincount = 1
			for sk in qc.texturegroup WHERE sk.count > 0 do (
				
				if sk.count == 1 then (

					local vmt =  (wallworm_VMFIMPORT_getMaterial (sk[1])  color:undefined openLib:false matType:"model" extraPath:qc.materialp extraRootPaths:#(extaPath))
						
					if vmt == undefined then (
						vmt = Standard name:(sk[1])
					)	
					
					

					newMultiMat.materialList[skincount] = vmt
				) else (
					local subskinMulti = MultiMaterial name:(("Skin"+skincount as string)) numsubs:sk.count
					skCount = 1
					for multsk in sk do (
						local vmt =  (wallworm_VMFIMPORT_getMaterial (multsk)  color:undefined openLib:false matType:"model" extraPath:qc.materialp extraRootPaths:#(extaPath)) 
						if vmt == undefined then (
							vmt = Standard name:(multsk)
						)	
						subskinMulti.materialList[skCount] = vmt
						skCount+=1
					)
					newMultiMat.materialList[skincount] = subskinMulti

				)
				newMultiMat.names[skincount] = ("Skin"+skincount as string)
				skincount += 1
			)
			
		)
			
			

			
			if buildMesh == true then (
				if qc.model != undefined AND qc.modelname != undefined OR qc.bodygroups.count>0 then (

					local smd = wallworm_getSMDsFromPaths qc.model qc.modelname fsource
					--print smd
					
					if smd == undefined AND qc.bodygroups.count > 0 then (
						
						smd = wallworm_getSMDsFromPaths qc.bodygroups[1].bgs[1] qc.modelname fsource
						
						
					)
					
					
					
					if smd != undefined AND smd != "" then (
						
						wwmt = wallworm_make_wwmt_from_smd_in_qc qc smd 

						if wwmt != undefined then (
							local qcistr = wwmt.createCustomQCI()
							
							if doesFileExist qcistr then (
								
							if qc.includesToAdd.count >0 OR qc.unclassified.count >0 then (
										
									
							 local CustomQCFile = OpenFile( qcistr) mode:"a"
									
								for inc in qc.includesToAdd do (
									str = "$include \""+inc+"\"\n"
									Format str to:CustomQCFile
								)	
									
								for inc in qc.unclassified do (
									str = inc+"\n"
									Format str to:CustomQCFile
								)	
							
								try (
									close CustomQCFile	
									free CustomQCFile
									flush CustomQCFile
								) catch ()
									
									
									
								)
								
								
								
							)
							
							
								/*
							tempWWMT.setBase(base)
									
				
							tempWWMT.setDmg_bullets(dmg_bullets)
							tempWWMT.setDmg_club(dmg_club)
							tempWWMT.setDmg_explosive(dmg_explosive)
							tempWWMT.setFadetime(fadetime)
								*/
								
							
							if qc.phys != undefined  then (
								

								if qc.model != undefined AND toLower (qc.model) == toLower ( qc.phys) then (
									wwmt.setAutoHull(true)
								
								) else (
									
									physsmd = wallworm_getSMDsFromPaths qc.phys qc.modelname fsource

									if physsmd != undefined  then ( 
										
										mshphy = wallworm_import_smd physsmd materialp:qc.materialp  deepSearchMaterials:deepSearchMaterials removeUnweightedBonesFromSkin:removeUnweightedBonesFromSkin rotateModel:rotateModel rotationAmount:rotationAmount  zeroRotations:zeroRotations  xf:xf uniqueNames:uniqueNames collapseMeshes:collapseMeshes  staticprop:qc.staticprop skipAnimation:true staticprop:qc.staticprop addToTimeline:false isSequence:false

										if mshphy != undefined AND mshphy.count > 0 then (
											
											for h in mshphy do (
												wwmt.appendHull h
											)
											
											wwmt.processPhys()
											
											hide wwmt.hulls
											
										)
													
										if scaleSMDs == true then (
											
											toScale = for obj in mshphy WHERE obj.parent == undefined collect obj
											
											toScale.scale *= qc.sc
											if xf == true then (
											
												resetXForm toScale
												convertToPoly toScale
												
											)
										)
										
									)								
								)
								
								
								
								

							
								
								
								
							)

							if NOT skipLODS then (
							
							
	/*
							if qc.shadowlod == true AND qc.lods.count > 0 then (
								deleteItem qc.lods qc.lods.count
							)
							
							
		*/
							
							
							--print lods
							if qc.lods.count > 0  then (
								
								for i=1 to qc.lods.count do (
									
									ld = qc.lods[i]
									
									newLod = ww_lod();
									newLod.wrapper = wwmt
									newLod.level = i
									newLod.metric = ld.val as float
									newLod.newMR()
									newLod.setGizmo (64 * i)			
									
									for m in ld.replacemodels do (
										
										
										smd = wallworm_getSMDsFromPaths (getFileNameFile m) qc.modelname fsource
											
										if smd != undefined AND smd != "" then ( 
											
											l = wallworm_import_smd smd materialp:qc.materialp  deepSearchMaterials:deepSearchMaterials removeUnweightedBonesFromSkin:removeUnweightedBonesFromSkin rotateModel:rotateModel rotationAmount:rotationAmount   zeroRotations:zeroRotations  xf:xf uniqueNames:uniqueNames collapseMeshes:false  staticprop:qc.staticprop addToTimeline:false isSequence:false
											if l != undefined AND l.count > 0 then (
												/*
												local newLod = wwmt.makeLOD i l[1] 100 l[1].name wwmt updateui:false


												*/
												--newLod = wwmt.setLod i l[1] wwmt alertMessage:false
												

												--append newLod.items l[1]

												
												
												
												if l.count > 0 then (
													for lodin = 1 to l.count do (
														--newLod.appendItem l[lodin]
														
														append newLod.items l[lodin]
														hide l[lodin]
													)
												)
												
												hide l
												

												
												if scaleSMDs == true then (
													
													toScale = for obj in l WHERE obj.parent == undefined collect obj
													
													toScale.scale *= qc.sc
													if xf == true then (
													
														resetXForm toScale
														convertToPoly toScale
														
													)
												)
												
												
												
											)
											
										)
										
									)
									
									
									

									newLod.setCustomAttributes()
									newLod.helperTape.setRadiusFromMetric (ld.val as float)
									newMats = #()
									for m in ld.replacematerials do (
										
										local theVMT = wallworm_VMFIMPORT_getMaterial (m)  color:undefined openLib:false matType:"model" extraPath:materialp extraRootPaths:fsourcepath
										
										if  theVMT != undefined then (
												append newMats theVMT
												--mat.materialList[i] = wallworm_generateMaterialFromVMT theVMT matType:"model" extraPath:materialp 

										)
										
										
									)
									
									if newMats.count > 0 then (
										
										lodmat = MultiMaterial numsubs:newMats.count name:(wwmt.modelname+" LOD "+newLod.level  as string+" Material")
										for mi = 1 to newMats.count do (
											lodmat.materialList[mi] =newMats[mi]
										)
										newLod.helperTape.setLODMaterial lodmat
										
									)
									
								
								)
								
							)
							
						)

							
							
							
							if qc.seqvals.count > 0 then (
								global wwmt_sequence
								--AnimLayerManager.enableLayers <&node array>nodes pos:<boolean> rot:<boolean> scale:<boolean> ik:<boolean> object:<boolean> customAtt:<boolean> mod:<boolean> mat:<boolean> other:<boolean>
								
								for seq  in qc.seqvals WHERE seq.count >= 3 AND seq[2] != "idle" do (
									local seqnam = substituteString seq[3] "\"" ""
									smd = wallworm_getSMDsFromPaths (seqnam+".smd") seqnam fsource
									if smd != undefined AND smd != "" then ( 
										
										wwseq = wwmt_sequence()
										wwseq.type = "Sequence"
										wwseq.sequence = substituteString seq[2] "\"" ""
										
										local ct = seq.count
										
										local actPlace = findItem seq "activity" 
										actVal = actPlace + 1
										if actPlace != 0 AND actVal <= ct AND seq[actVal] != undefined then (
												wwseq.activity = seq[actVal]
										)
										
										
										
										
										activityWeightPlace = actVal + 1
										if activityWeightPlace <= ct AND seq[activityWeightPlace] != undefined AND seq[activityWeightPlace] as float != undefined then (
												wwseq.activityWeight = seq[activityWeightPlace] as float
										)
										
										
										
										
										local actPlace = findItem seq "node" 
										actVal = actPlace + 1
										if actPlace != 0 AND actVal <= ct AND seq[actVal] != undefined then (
												wwseq.nd = seq[actVal] as string
										)
										
										
										
										
										local fpsPlace = findItem seq "fps" 
										actVal = fpsPlace + 1
										if fpsPlace != 0 AND actVal <= ct AND seq[actVal] != undefined then (
												wwseq.fps = seq[actVal] as float
										)
										

										lookforsimple = #("autoplay", "snap", "realtime", "hidden")
										for prop in lookforsimple do (
											if findItem seq prop == 0 then (
												setProperty wwseq prop false
											) else (
												setProperty wwseq prop true
											)
										)
										
										if findItem seq "loop" == 0 then (
											
											wwseq.loop = 0
										) else (
											wwseq.loop = 1
										)
										


										local fadeInPlace = findItem seq "fadein" 
										if fadeInPlace == 0 then (
											fadeInPlace = findItem seq "fadeIn" 
										)
										actVal = fadeInPlace + 1
										if fadeInPlace != 0 AND actVal <= ct AND seq[actVal] != undefined then (
												wwseq.fadeIn = seq[actVal]
										)
										

										local fadeOutPlace = findItem seq "fadeout" 
										if fadeOutPlace == 0 then (
											fadeOutPlace = findItem seq "fadeOut" 
										)
										actVal = fadeOutPlace + 1
										if fadeOutPlace != 0 AND actVal <= ct AND seq[actVal] != undefined then (
												wwseq.fadeOut = seq[actVal]
										)
										
										
										
										wwseq.start = wallworm_smd_import_time
										s = wallworm_import_smd smd materialp:qc.materialp  deepSearchMaterials:deepSearchMaterials removeUnweightedBonesFromSkin:removeUnweightedBonesFromSkin rotateModel:rotateModel rotationAmount:rotationAmount   zeroRotations:zeroRotations  xf:xf uniqueNames:false collapseMeshes:false  staticprop:false isSequence:false timeOffset:wallworm_smd_import_time seqName:"seq"
									
										wwseq.end = wallworm_smd_import_time
										
										wwseq.setSequence wwmt.target
										
										append wwmt.sequences wwseq
										
										
									)
								
								
							)
								

							

								
									/*parse sequence array data */
								
							)

							if extraSequences != undefined AND doesFileExist extraSequences then (
								global wwmt_sequence
								
								local autoimportseqs = getFiles (extraSequences+"\\*.smd")	
								
								if autoimportseqs != undefined AND autoimportseqs.count > 0   then (
									
									for autoseq in autoimportseqs do (
										seqnam = getFilenameFile autoseq
										
										smd = wallworm_getSMDsFromPaths (autoseq) seqnam fsource
										if smd != undefined AND smd != "" then ( 
											
											wwseq = wwmt_sequence()
											wwseq.type = "Sequence"
											wwseq.sequence=seqnam
											
											wwseq.start = wallworm_smd_import_time
											s = wallworm_import_smd smd materialp:qc.materialp  deepSearchMaterials:deepSearchMaterials removeUnweightedBonesFromSkin:removeUnweightedBonesFromSkin rotateModel:rotateModel rotationAmount:rotationAmount   zeroRotations:zeroRotations  xf:xf uniqueNames:false collapseMeshes:false  staticprop:false isSequence:false timeOffset:wallworm_smd_import_time seqName:"seq"
										
											wwseq.end = wallworm_smd_import_time
											
											wwseq.setSequence wwmt.target
											
											append wwmt.sequences wwseq
											
											
										)
										
										
									)
									
									
								)
								
								
							)
							
							
							if wwmt.sequences.count > 0 then (
								wwmt.setSeqListCust()
								
							)

							
							
							local bgMapNames = #(qc.model)
							
							if qc.bodygroups.count>0 AND qc.model != undefined then (
								
								
								for bg in qc.bodygroups do (
									
									local bgDummy = Dummy pos:(wwmt.target.pos) name:bg.name

									custAttributes.add bgDummy wallworm_bodygroup_CA
									
									for bodyline IN bg.bgs do (
										
										
										
										if findItem bgMapNames bodyline == 0 then (
											smd = wallworm_getSMDsFromPaths bodyline qc.modelname fsource
											if smd != undefined then (
												bgwwmt = wallworm_make_wwmt_from_smd_in_qc qc smd 
												bgwwmt.setModelName (getFileNameFile smd)
												
												append bgDummy.wwmts bgwwmt.target
												
												
												
											)
										)
										
										
										
									)


								)
								
								
								
								
								
								
							)
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							select (wwmt.target)
						)
					)
					

				
			)
			
			
			sliderTime = wallworm_smd_import_time			
			
			) else (
			
			/*all we want is the modelname*/
			wwmt = qc.modelname
			)
			

			
			global wallworm_smd_import_time = 0
			
			
			if OLDdfltInTangentType != undefined AND OLDdfltOutTangentType != undefined then (
				maxOps.setDefaultTangentType OLDdfltInTangentType OLDdfltOutTangentType writeInCfgFile:false
			)
			
			wwmt
		)


		
		